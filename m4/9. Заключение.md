### Выводы

####
`
Как только вы привыкнете к программированию в таком стиле (путем настройки программного обеспечения), вы обнаружите, что когда наступает время написания новой программы, большая часть работы может оказаться сделанной — в значительной степени ваша задача сводится к смешиванию существующих суперклассов, которые уже реализуют поведение, требующееся для программы.
`

* Класс — тип данных описывающий объект
* Объект — тип данных, экземпляр класса
* Метод объекта — сообщение, с помощью которого объекты общаются друг с другом
* Атрибут объекта — хранилище текущего состояния объекта
* Свойство объекта — интерфейс доступа к атрибутам объекта
* Класс — самостоятельный тип. Может иметь свои методы и атрибуты

* ООП — это в основном аргумент по имени `self` и поиск атрибутов в деревьях связанных объектов, называемых наследованием.

* Модель ООП в Python очень проста

`
Фактически во многих прикладных областях вы можете выбрать или приобрести наборы суперклассов, известные как фреймворки, которые реализуют распространенные задачи программирования в виде классов, готовых к смешиванию в ваших приложениях. 
`

Подобные фреймворки могут предоставлять интерфейсы к базам данных, протоколы тестирования, комплекты инструментов для построения графических пользовательских интерфейсов и т.д.


Располагая фреймворками, вы часто просто пишете код
подкласса, в котором реализуете один или два ожидаемых метода; большую часть работы выполняют классы фреймворков, находящиеся выше в дереве. 

Программирование
в таком мире ООП представляет собой всего лишь комбинирование и специализацию уже отлаженного кода за счет написания собственных подклассов.
`

#### Классы обладают только тремя отличительными особенностями:

На базовом уровне они главным образом представляют собой пространства имен, что во многом подобно модулям

Однако в отличие от модулей классы также поддерживают:

* генерирование множества объектов
* наследование пространств имен
* перегрузку операций. 


## Вопросы 

1. В чем сущность ООП в Python?

<details>
<summary>Ответ</summary>
Многократное использование кода — вы производите разложение кода с целью минимизации избыточности и программируете путем настройки того, что уже существует, а не изменяете код на месте или пишете его
с нуля
</details>

2. В чем отличие между объектом класса и объектом экземпляра?
<details>
<summary>Ответ</summary>
Объекты классов и объекты экземпляров представляют собой пространства имен (пакеты переменных, которые выступают в качестве атрибутов). 

Основное отличие между ними в том, что классы являются своего рода фабриками для создания множества экземпляров. 
</details>

3. Почему первый аргумент в функции метода класса является особым?
<details>
<summary>Ответ</summary>
Первый аргумент в функции метода класса является особым, потому что
он всегда получает объект экземпляра, представляющий собой подразумевамый объект, на котором вызван метод. 

По соглашению он называется self.
 </details>

3. Для чего применяется метод__ init__ ?
<details>
<summary>Ответ</summary>
Метод __ init__ реализуется или наследуется в классе, и Python вызывает его автоматически каждый раз, когда создается экземпляр этого класса. Он известен как метод конструктора; ему неявно передается новый экземпляр, а также любые аргументы, указанные явно с именем класса. 

Кроме того, он является наиболее часто применяемым методом перегрузки операций. 

В случае отсутствия метода__ init__ экземпляры просто начинают свое существование как пустые пространства имен.
 </details>


5. Как бы вы создали экземпляр класса?
<details>
<summary>Ответ</summary>
Вы создаете экземпляр класса с помощью обращения к имени класса так,
как если бы оно было функцией. Любые аргументы, указанные с именем класса, становятся вторым и последующими аргументами в методе конструктора __ init__ . 

Новый экземпляр запоминает класс, из которого он был создан, для целей, связанных с наследованием
 </details>

6. Как бы вы создали класс?

<details>
<summary>Ответ</summary>
Вы создаете класс посредством выполнения оператора class; 

подобно определениям функций такие операторы обычно выполняются при импортировании включающего модул
 </details>

